---
title: "Day 14 - Introduction to D3"
output:
  html_document:
    highlight: pygments
    theme: readable
    toc: yes
    toc_float: yes
    code_folding: show
    includes:
      in_header: "header_include_d3.html"
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(cache = TRUE, warning = FALSE, message = FALSE)
```

# Objectives

* Review how to add scales and axes to D3 plots
* Identify methods for updating graphs and transitioning
* Define event listeners and identify potential events
* Explain how to incorporate interactivity by binding event listeners

```{r packages, cache = FALSE, message = FALSE}
library(tidyverse)
library(knitr)
library(broom)
library(stringr)
library(modelr)
library(forcats)
library(ggmap)
library(plotly)

options(digits = 3)
set.seed(1234)
theme_set(theme_minimal())
```

# Scales

> Scales are functions that map from an input domain to an output range.

**Scales** allow for D3 graphics to dynamically adjust to different absolute values in the data. This is equivalent to the `scale_*()` family of functions in `ggplot2` and the scale component of the layered grammar of graphics.

D3 scales are functions with parameters that you define. D3 will not just assume a certain type of scale given the data values - you need to explicitly declare it. Scales themselves are not visual elements of the graph. That is, scales do not define axes that are drawn to visualize the scale along the x and y coordinates. For that, we still need to explicitly create an **axis** which is the visual representation of the scale.

## Domains and ranges

* Input domain - range of possible input data values. Identified by the actual values encoded in the variables
* Output range - range of possible output values. In D3, this is frequently displayed as values in pixel units

![](http://orm-chimera-prod.s3.amazonaws.com/1230000000345/images/idvw_0701.png)

## Creating the scale

D3's scale functions are accessed with `d3.scale` followed by the type of scale you want:

```javascript
var scale = d3.scale.linear();
var scale = d3.scale.sqrt();
var scale = d3.scale.log();
var scale = d3.scale.ordinal();
```

To properly use these functions, we need to set a domain and a range by passing the values into `scale` as arguments (stored as arguments):

```javascript
scale.domain([100, 500]);
scale.range([10, 350]);

// chained together
var scale = d3.scale.linear()
                    .domain([100, 500])
                    .range([10, 350]);
                    
scale(100);  //Returns 10
scale(300);  //Returns 180
scale(500);  //Returns 350
```

## Scaling the scatterplot

To be flexible, we don't want to hard code the values for the domain and range. What happens if the data values change? We want the scale to automatically adjust. Remember the data for the scatter plot is stored as an array of arrays:

```javascript
var dataset = [
                [5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
                [410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
              ];
```

### `d3.min()` and `d3.max()`

We can use `d3.min()` and `d3.max()` to calculate the minimum and maximum values in our data set. Because the x and y coordinates are stored as arrays within an array, we need to loop over each array, pull out the x coordinate, and then calculate the minimum and maximum values for all the x coordinates:

```javascript
d3.max(dataset, function(d) {
    return d[0];  //References first value in each subarray
});
```

`function(d)` is an anonymous **accessor** function which retrieves the first indexed value from each array in `dataset` (this is what `d` refers to). This is similar to the other anonymous functions we used to calculate the coordinates for plotting the scatterplot circles:

```javascript
.attr("cx", function(d) {
    return d[0];
})
.attr("cy", function(d) {
    return d[1];
})
```

### Setting up dynamic scales

```javascript
var xScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[0]; })])
                     .range([0, w]);
```

* `xScale` - give it a meaningful name
* Bottom of domain and range are hardcoded to `0`. You could calculate the minimum value in the dataset instead
* Output range is set to `0` and `w`, the SVG's width

```javascript
var yScale = d3.scale.linear()
                     .domain([0, d3.max(dataset, function(d) { return d[1]; })])
                     .range([0, h]);
```

### Incorporating scaled values

Now we need to update the coordinates for the `circle` for each data value:

```javascript
.attr("cx", function(d) {
    return d[0];  //Returns original value bound from dataset
})

.attr("cx", function(d) {
    return xScale(d[0]);  //Returns scaled value
})
```

And for the text labels:

```javascript
.attr("x", function(d) {
    return xScale(d[0]);
})
.attr("y", function(d) {
    return yScale(d[1]);
})
```

The result is:

```javascript
			//Width and height
			var w = 500;
			var h = 100;
			
			var dataset = [
							[5, 20], [480, 90], [250, 50], [100, 33], [330, 95],
							[410, 12], [475, 44], [25, 67], [85, 21], [220, 88]
						  ];
			//Create scale functions
			var xScale = d3.scale.linear()
								 .domain([0, d3.max(dataset, function(d) { return d[0]; })])
								 .range([0, w]);
			var yScale = d3.scale.linear()
								 .domain([0, d3.max(dataset, function(d) { return d[1]; })])
								 .range([0, h]);
	
			//Create SVG element
			var svg = d3.select("body")
						.append("svg")
						.attr("width", w)
						.attr("height", h);
			svg.selectAll("circle")
			   .data(dataset)
			   .enter()
			   .append("circle")
			   .attr("cx", function(d) {
			   		return xScale(d[0]);
			   })
			   .attr("cy", function(d) {
			   		return yScale(d[1]);
			   })
			   .attr("r", function(d) {
			   		return Math.sqrt(h - d[1]);
			   });
			svg.selectAll("text")
			   .data(dataset)
			   .enter()
			   .append("text")
			   .text(function(d) {
			   		return d[0] + "," + d[1];
			   })
			   .attr("x", function(d) {
			   		return xScale(d[0]);
			   })
			   .attr("y", function(d) {
			   		return yScale(d[1]);
			   })
			   .attr("font-family", "sans-serif")
			   .attr("font-size", "11px")
			   .attr("fill", "red");
```

* [Result](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_07/02_scaled_plot.html)

### Tweaking the graph

We still need to make some adjustments to the graph:

* Remember that SVGs are drawn from the top-down. We need to reverse `yScale` so greater values are higher up. To do that, change

    ```javascript
    .range([0, h]);
    ```
    
    to
    
    ```javascript
    .range([h, 0]);
    ```

* Add padding to the range so that elements near the borders are not cut off. Similar to adding padding previously:

    ```javascript
    xScale.range([padding, w - padding]);
    yScale.range([h - padding, h]);
    ```

* Use a scale function to calculate the radius of each `circle` as the square root of its `y` value.

    ```javascript
    var rScale = d3.scale.linear()
                         .domain([0, d3.max(dataset, function(d) { return d[1]; })])
                         .range([2, 5]);
    .attr("r", function(d) {
        return rScale(d[1]);
    });
    ```

* [Result with original data](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_07/05_scaled_plot_radii.html)
* [Result with new data point](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_07/06_scaled_plot_big.html)
* [Result with new SVG size](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_07/07_scaled_plot_large.html)

# Axes

Much like scales, D3 axes are functions whose parameters you define. Rather than returning a value, they generate visual elements of the axis, including lines, labels, and ticks.

## Setting up an axis

Use `d3.svg.axis()` to create a generic axis function:

```javascript
var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom");
```

* Assigns the x-axis to a variable
* Assigns it a scale
* Orients labels to appear on the bottom of the axis

To generate the axis and add it to the plot, we need to `call()` the `xAxis` function.

```javascript
svg.append("g")
    .call(xAxis);
```

* Reference the `svg` element
* `append()` a new `g` element to it. `g` is a group element that are invisible, but group together common elements. Think of an axis - it includes a line across the graph, tick marks, text labels, etc. We want them grouped together so we can apply common styles and aesthetics to the entire axis.
* `call()` takes the incoming `g` group and sends it to the `xAxis` function (variable). It's like a basic chaining operation in R.
* Remember that SVGs are drawn one element at a time. If you draw the axis first, other visual elements of the graph can be drawn over top of it. Typically this is not desired and you want the axis to be on top, so add it at the end of your code after the other elements in the SVG are generated. Again, similar to adding layers in `ggplot()`

* [Result - not pretty](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_08/01_axes.html)

## Cleaning it up

We need to assign the axis (`g` element) to a **class* so we can alter its aesthetics with CSS:

```javascript
svg.append("g")
    .attr("class", "axis") //Assign "axis" class
    .call(xAxis);
```

Then add some CSS styles in the `<head>` of the page (or in an external file):

```css
.axis path,
.axis line {
    fill: none;
    stroke: black;
    shape-rendering: crispEdges;
}

.axis text {
    font-family: sans-serif;
    font-size: 11px;
}
```

* The first chunk applies to the axis path and line, changing the `fill` to `none`, the line stroke color to `black`, and giving it `crispEdges`
* The axis text changes its font family and size

To move the axis to the bottom of the graph, we **transform** it:

```javascript
svg.append("g")
    .attr("class", "axis")
    .attr("transform", "translate(0," + (h - padding) + ")")
    .call(xAxis);
```

This is a new `transform` attribute that `translate()`s the x and y coordinates of the axis. Here, we just want to change the vertical position of the graph, so the first argument is `0`.

* [Result](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_08/02_axes_bottom.html)

## Check for ticks

We can adjust the number of ticks when creating the axis:

```javascript
var xAxis = d3.svg.axis()
                  .scale(xScale)
                  .orient("bottom")
                  .ticks(5);  //Set rough # of ticks
```

This will create approximately 5 tick marks. However D3 will interpret this as a suggestion and pick the optimal number of human-readable values. In this case, D3 will choose 7 ticks so it can round each tick label to the nearest 100 value (e.g. 100, 200, 300).

* [Result](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_08/03_axes_clean.html)
* [Result with y-axis](https://htmlpreview.github.io/?https://github.com/alignedleft/d3-book/blob/master/chapter_08/04_axes_y.html)




# Updates, Transitions, and Motion


# Interactivity


## Event listeners


## Binding event listeners


### Hover to highlight


### Click to sort


### Adding tooltips


# Layouts and geomapping


# Examples of D3 graphics

* [Popular Blocks](https://bl.ocks.org/)

# Acknowledgments {.toc-ignore}

* [Murray, Scott. *Interactive data visualization for the Web*. O'Reilly Media, Inc., 2013.](http://alignedleft.com/work/d3-book)

# Session Info {.toc-ignore}

```{r cache = FALSE}
devtools::session_info()
```


